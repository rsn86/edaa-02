# -*- coding: utf-8 -*-
"""EDAA-Avaliacao01.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1-uu-8JWry7L_cEV1481qsgIHO5QkpN4X

UNIVERSIDADE ESTADUAL DO OESTE DO PARANÁ - UNIOESTE
PROGRAMA DE PÓS GRADUAÇÃO EM CIÊNCIA DA COMPUTAÇÃO – PPGCOMP


Estruturas de Dados e Análise de Algoritmos - EDAA

Avaliação 1.1 – Algoritmos de Busca – Parte 1

##1) Descrição
Esta atividade individual consiste em implementar e comparar empiricamente a eficiência dos seguintes métodos de busca considerando arranjos estáticos com valores inteiros:
* Busca sequencial padrão;
* Busca por saltos (jump search);
* Busca binária.

## 2) Casos de Teste
Para realizar a comparação, devem ser gerados diferentes cenários de teste aleatórios variando-se o tamanho do arranjo de 100.000 a 1.000.000, em intervalos de 100 mil.

Calcular média e desvio padrão para o número de comparações e o tempo de execução considerando:
* O pior caso, com 3 execuções de cada;
* Casos aleatórios: 100 buscas para cada cenário.

## 3) Execução
* A linguagem de programação é livre;
* Para preencher o arranjo, pode ser usado um método pseudoaleatório random) disponível na linguagem mantendo-se a seed em cada cenário para os diferentes algoritmos comparados (uma função de shuffle também pode ser utilizada);
 * Os valores não devem se repetir;
 * O custo de criação do arranjo deve ser descartado;
* O custo de ordenação, quando necessário, deve ser computado no custo total, mas registrado
e discutido individualmente.
 *  Utilize um método de ordenação disponível na linguagem;
* Se o tempo de execução for muito pequeno, pode-se incluir um custo constante em cada
comparação da chave de busca com o elemento do arranjo.

## 4) Entrega
Os resultados devem ser apresentados em até 4 (quatro) páginas em PDF no formato de artigos da SBC – Sociedade Brasileira de Computação disponível em [Modelos para Publicação de Artigos](https://www.sbc.org.br/documentos-da-sbc/category/169-templates-para-artigos-e-capitulos-de-livros). Incluir Resumo/Abstract, Introdução, Materiais e Métodos, Resultados, Conclusão e Referências bibliográficas.

## Configuração do ambiente
"""

# Listar locales instalados
!locale -a

# Instalar o locale pt_BR
!/usr/share/locales/install-language-pack pt_BR
!dpkg-reconfigure locales

# Listar locales instalados
!locale -a

# Reinicar o processo do python para enxergar o locale pt_BR
import os
os.kill(os.getpid(), 9)

# Ignorar alerta de itens depreciados
import warnings
warnings.simplefilter(action='ignore', category=FutureWarning)

# Definir o locale pt_BR
import locale
locale.setlocale(locale.LC_NUMERIC, 'pt_BR.ISO8859-1')

"""## Código"""

# Definições
TAM_ARRANJO_MIN =   100_000
TAM_ARRANJO_MAX = 1_000_000
TAM_ARRANJO_INC =   100_000

EXEC_DESCATAR_MAIOR = 2
EXEC_ORDENACAO = 3 + EXEC_DESCATAR_MAIOR
EXEC_PIOR_CASO = 3 + EXEC_DESCATAR_MAIOR
EXEC_BUSCAS = 100 + EXEC_DESCATAR_MAIOR

FATOR_ESPALHAMENTO = 100

# pacotes utilizados
import sys                                  # Aborta ao detectar um resultado inesperado
import random                               # Utilizado na geração do arranjo e da chave de busca - inteiros (pseudo)aleatórios
import pandas as pd                         # Utilizado para calcular os resultados agregados das execuções

from math import sqrt                       # Utilizado no cálculo do tamanho do salto/bloco - busca_por_saltos
from collections import namedtuple          # Utilizado para armazenar os resultados da execução de cada busca realizada
from collections.abc import Sequence        # Type hint nas funções que aceitam arranjos
from timeit import default_timer as timer   # Utilizado na temporização das buscas e ordenações
from types import FunctionType              # Type hint na função executar_busca, que aceita uma função metodo (de busca) como argumento
from typing import Union                    # Type hint nas funções de busca, que retornam um int ou None

# variáveis globais
resultados = list()

# semente de aleatoriedade fixa para assegurar reprodutibilidade
random.seed(42)                             # o sentido da vida, o universo e tudo mais

def gerar_arranjo(tamanho: int) -> Sequence:
  '''
  Gera um arranjo aleatório não ordenado com tamanho elementos e valores entre 0 e o tamanho do arranjo * o fator de espalhamento
  '''
  return random.sample(range(tamanho * FATOR_ESPALHAMENTO), tamanho)

def gerar_chave_aleatoria(arranjo: Sequence) -> int:
  '''
  Gera uma chave de busca escolhendo, com igual probabilidade, entre:
  um valor qualquer entre 0 e o tamanho do arranjo * o fator de espalhamento e
  um valor qualquer presente no arranjo
  Probabilidade da chave estar presente no arranjo = 1/fator espalhamento + 0,5
  '''
  chave_existente = random.choice(arranjo)
  return random.choice([random.randrange(len(arranjo) * FATOR_ESPALHAMENTO), chave_existente])

def gerar_chave_pior_caso(arranjo: Sequence) -> int:
  '''
  Dado um um arranjo, gera uma chave que corresponde ao pior caso para todos os algoritmos de busca considerados
  '''
  # Busca sequencial: Percorrer toda o arranjo (chave último elemento ou chave inexistente)
  # Busca por saltos: Percorrer todo o arranjo (chave último elemento)
  # Busca binária   : Percorrer todo o arranjo (chave último elemento ou maior que o último)
  chave = arranjo[-1]  # Chave de pesquisa igual ao último elemento
  return chave

Resultado = namedtuple('Resultado', [
    'tamanho_arranjo',
    'rodada',
    'min',
    'max',
    'chave',
    'presente',
    'metodo',
    'comparacoes',
    'tempo',
    'posicao',
    'cenario'
])

Resultado.__doc__ += ': Armazena o resultado de uma execução de busca em arranjo'
Resultado.tamanho_arranjo.__doc__ = 'Tamanho do arranjo no qual se efetuou a busca'
Resultado.rodada.__doc__ = 'Número da rodada de testes'
Resultado.min.__doc__ = 'Menor valor no arranjo'
Resultado.max.__doc__ = 'Maior valor no arranjo'
Resultado.chave.__doc__ = 'Chave buscada'
Resultado.presente.__doc__ = 'Indica se o valor da chave está presente ou não no arranjo'
Resultado.metodo.__doc__ = 'Método de busca utilizado'
Resultado.comparacoes.__doc__ = 'Número de comparações efetuados'
Resultado.tempo.__doc__ = 'Tempo gasto na busca/ordenação'
Resultado.posicao.__doc__ = 'Posição na qual a chave de busca foi encontrada'
Resultado.cenario.__doc__ = 'Cenário da execução ordenação ou busca: aleatório ou pior caso'

def registrar_resultado(resultado: Resultado):
  '''
  Salva um resultado individual na lista de resultados
  '''
  global resultados
  resultados.append(resultado)

def busca_sequencial(arranjo: Sequence, chave: int, **kwargs) -> tuple[Union[int, None], int]:
  '''
  Implementação do algoritmo da busca sequencial em arranjos.
  Percorre todo o arranjo, comparando cada elemento elemento com a chave de busca.
  Retorna a posição da chave no arranjo ou None caso o elemento não esteja presente no arranjo.
  Parâmetros obrigatórios:
  arranjo: sequência de elementos
  chave: chave de busca
  Parâmetros opcionais (nomeadods):
  esquerda: posição inicial da busca (default, 0)
  direita: posição final da busca (default, tamanho do arranjo)
  '''
  comparacoes = 0
  esquerda = kwargs.get('esquerda', 0)
  direita  = kwargs.get('direita' , len(arranjo))

  for indice, elemento in zip(range(esquerda, direita), arranjo[esquerda:direita]):
    comparacoes += 1
    if elemento == chave:
      return (indice, comparacoes)

  return (None, comparacoes) # Não encontrou

def busca_por_saltos(arranjo: Sequence, chave: int, **kwargs) -> tuple[Union[int, None], int]:
  '''
  Implementação do algoritmo da busca sequencial em arranjos.
  Tamanho do salto/bloco fixo: raiz quadrada do tamanho do arranjo.
  Percorre o arranjo, saltando para frente de salto em salto, até encontrar um elemento maior ou igual à chave de busca.
  Quando isso acontece, salta para trás salto elementos e realiza uma busca sequência no bloco.
  Retorna a posição da chave no arranjo ou None caso o elemento não esteja presente no arranjo.
  Parâmetros obrigatórios:
  arranjo: sequência de elementos ordenados
  chave: chave de busca
  Parâmetros opcionais (nomeadods):
  ordenado: flag indicando se o arranjo está ordenado ou não (default, não ordenado)
  esquerda: posição inicial da busca (default, 0)
  direita: posição final da busca (default, tamanho do arranjo)
  '''
  comparacoes = 0
  esquerda = kwargs.get('esquerda', 0)
  direita  = kwargs.get('direita' , len(arranjo))

  ordenado = kwargs.get('ordenado', False)
  if not ordenado:
    raise ValueError('arranjo deve estar ordenado')

  salto = int(sqrt(direita - esquerda))

  ultimo_elemento_bloco = min(esquerda + salto, direita - 1)
  while ultimo_elemento_bloco < direita:
    comparacoes += 1
    if arranjo[ultimo_elemento_bloco] >= chave:
      inicio_bloco = max(0, ultimo_elemento_bloco - salto + 1)
      posicao, comparacoes_seq = busca_sequencial(arranjo, chave, esquerda=inicio_bloco, direita=ultimo_elemento_bloco + 1)
      return (posicao, comparacoes + comparacoes_seq)
    ultimo_elemento_bloco = min(ultimo_elemento_bloco + salto, direita - 1)

  return (None, comparacoes) # Não encontrou

def busca_binaria(arranjo: Sequence, chave: int, **kwargs) -> tuple[Union[int, None], int]:
  '''
  Implementação  do algoritmo de busca binária em arranjos.
  Divide sucessivamente o arranjo ao meio, comparando elemento central com a chave, caso este seja:
  igual à chave    : retorna a posição
  maior que a chave: busca no segmento inferior [esquerda, meio - 1]
  menor que a chave: busca no segmento superior [meio + 1, direita ]
  Parâmetros obrigatórios:
  arranjo: sequência de elementos ordenados
  chave: chave de busca
  Parâmetros opcionais (nomeadods):
  ordenado: flag indicando se o arranjo está ordenado ou não (default, não ordenado)
  esquerda: posição inicial da busca (default, 0)
  direita: posição final da busca (default, tamanho do arranjo - 1)
  '''
  comparacoes = 0
  esquerda = kwargs.get('esquerda', 0)
  direita  = kwargs.get('direita' , len(arranjo) - 1)

  ordenado = kwargs.get('ordenado', False)
  if not ordenado:
    raise ValueError('arranjo deve estar ordenado')

  while esquerda <= direita:
    meio = esquerda + (direita - esquerda) // 2
    elemento = arranjo[meio]

    comparacoes += 1
    if chave == elemento:
      return (meio, comparacoes)
    elif chave < elemento:  # deve-se buscar na porção inferior
      direita = meio - 1
    else:
      esquerda = meio + 1   # deve-se buscar na porção superior

  return (None, comparacoes) # Não encontrou

def executar_busca(arranjo: Sequence, chave: int, metodo: FunctionType, cenario: str, ordenado = False) -> tuple[Union[int, None], int]:
  '''
  Para um dado cenário, busca a chave no arranjo utilizando o método de busca fornecido
  e registra o resultado da execução.
  '''
  if ordenado:
    menor_valor = arranjo[0]
    maior_valor = arranjo[-1]
  else:
    menor_valor = min(arranjo)
    maior_valor = max(arranjo)

  tempo = timer()
  posicao, comparacoes = metodo(arranjo, chave, ordenado=ordenado)
  tempo = timer() - tempo

  registrar_resultado(Resultado(
      tamanho_arranjo=tamanho_arranjo,
      rodada=rodada,
      min=menor_valor,
      max=maior_valor,
      chave=chave,
      presente=chave in arranjo,
      metodo=metodo.__name__.replace('busca_', '').replace('_', ' ').replace('binaria', 'binária').capitalize(),
      comparacoes=comparacoes,
      tempo=tempo,
      posicao=posicao,
      cenario=cenario
  ))

  return (posicao, comparacoes)

# Métodos de busca que serão avaliados
metodos_de_busca = (busca_sequencial, busca_por_saltos, busca_binaria)

# Executa as buscas para os diversos tamanhos de arranjo
for tamanho_arranjo in range(TAM_ARRANJO_MIN, TAM_ARRANJO_MAX + 1, TAM_ARRANJO_INC):
  arranjo = gerar_arranjo(tamanho_arranjo)

  for rodada in range(0, EXEC_ORDENACAO):
    tempo_ordenacao = timer()
    arranjo_ordenado = sorted(arranjo)
    tempo_ordenacao = timer() - tempo_ordenacao
    registrar_resultado(Resultado(
        tamanho_arranjo=tamanho_arranjo,
        rodada=0,
        min=arranjo_ordenado[0],
        max=arranjo_ordenado[-1],
        chave=None,
        presente=None,
        metodo='TimSort',
        comparacoes=None,
        tempo=tempo_ordenacao,
        posicao=None,
        cenario='Ordenação'
    ))
  ordenado = True

  # Cenário: Pior Caso
  chave = gerar_chave_pior_caso(arranjo_ordenado)
  for rodada in range(0, EXEC_PIOR_CASO):
    for metodo in metodos_de_busca:
      posicao, _ = executar_busca(arranjo_ordenado, chave, metodo, cenario='Pior Caso', ordenado=ordenado)
      if posicao != tamanho_arranjo - 1:
        sys.exit(f'Resultado diferente do esperado - método {metodo.__name__}. Esperado {tamanho_arranjo - 1} - Encontrado: {posicao}')

  # Cenário: Aleatório
  for rodada in range(0, EXEC_BUSCAS):
    chave = gerar_chave_aleatoria(arranjo_ordenado)
    for metodo in metodos_de_busca:
      executar_busca(arranjo_ordenado, chave, metodo, cenario='Aleatório', ordenado=ordenado)

"""### Calcular as estatíticas"""

df_bruto = pd.DataFrame(resultados) # Antes de descartar os maiores valores
df = df_bruto.copy()                # Será filtrado para descartar os maiores valores

# Descartar os EXEC_DESCATAR_MAIOR maiores tempos - devido ao warm up e ao fato do ambiente ser compartilhado
get_tamanho_metodo_cenario = lambda df: df[['tamanho_arranjo', 'metodo', 'cenario']].drop_duplicates().itertuples(index=False)
get_max_tempo_idx = lambda df, tamanho, metodo, cenario: df[(df['cenario'] == cenario) & (df['metodo'] == metodo) & (df['tamanho_arranjo'] == tamanho)]['tempo'].idxmax()

for tamanho, metodo, cenario in get_tamanho_metodo_cenario(df_bruto):
  for _ in range(0, EXEC_DESCATAR_MAIOR):
    try:
      max_tempo_idx = get_max_tempo_idx(df, tamanho, metodo, cenario)
    except ValueError: # Caso ocorra é seguro ignorar
      pass
    else:
      df.drop(max_tempo_idx, inplace=True)

# Separa os dados de ordenação dos dados de busa
df_ordenacao = df[df['cenario'] == 'Ordenação'].copy()
df_busca = df[df['cenario'] != 'Ordenação'].copy()

# Transforma os valores booleanos (True e False) em inteiros (1 e 0, respectivamente)
# Para calcular o % médio de buscas nos quais a chave estava presente no arranjo
# Pois a chave ausente corresponde ao pior caso da busca sequencial, e dependendo do valor, da binária também
df_busca['presente'] = df_busca['presente'].replace([True, False], [int(True), int(False)])

# Calcula as estatísticas descritivas: média, desvio padrão, mínimo, mediana (50% percentil) e máximo
# para as colunas tempo (de busca), número de comparações e % de buscas com chave pertencente ao arranjo
# dos resultados agrupados por tamanho do arranjo e método de busca (sequencial, por saltos e binária)
# serparada para os cenário de busca aleatório ou pior caso
df_aleatorio = df_busca[df_busca['cenario'] == 'Aleatório'].groupby(
    ['tamanho_arranjo', 'metodo']
)[['tempo', 'comparacoes', 'presente']].describe(percentiles=[])

# não selecionamos a coluna presente no cenário pior caso pois sempre será 1, não agregando informação
df_pior_caso = df_busca[df_busca['cenario'] == 'Pior Caso'].groupby(
    ['tamanho_arranjo', 'metodo']
)[['tempo', 'comparacoes']].describe(percentiles=[])

# só temos as medições de tempo
df_timsort = df_ordenacao[df_ordenacao['metodo'] == 'TimSort'].groupby(
    ['tamanho_arranjo', 'metodo']
)[['tempo']].describe(percentiles=[])

"""### Exibir resultados"""

# Formatadores
# transforma o float de s para ms e aplica a formação de acordo com a localização
to_ms = lambda s: locale.format_string('%.2f', 1000*s, grouping=True)
# aplica a formação de acordo com a localização - inteiros e floats
locale_format_int = lambda d: locale.format_string('%d', d, grouping=True)
locale_format_float = lambda f: locale.format_string('%.2f', f, grouping=True)

def renomear_coluna(coluna: str) -> str:
  if coluna == None:
    return None
  return coluna.\
    replace('tempo','Tempo (ms)').\
    replace('comparacoes','Comp.').\
    replace('presente', 'x ∈ A').\
    replace('mean','x̄').\
    replace('std', 'σ')

# Prepara o DataFrame para exibição/apresentação
def reformatar_df(df: pd.DataFrame, cenario: Union[str,None] = None) -> pd.DataFrame:
  # remover colunas indesejadas
  colunas_selecionadas = [coluna for coluna in df.columns if coluna[1] not in ('count','min','50%', 'max')]
  novo_df = df[colunas_selecionadas].copy()

  # renomear colunas
  if cenario is None:
    colunas_renomeadas = [(renomear_coluna(medida), renomear_coluna(estatistica)) for medida,estatistica in novo_df.columns.values]
  else:   # adiciona o cenário ao nome das colunas - MultiIndex
    colunas_renomeadas = [(cenario, renomear_coluna(medida), renomear_coluna(estatistica)) for medida,estatistica in novo_df.columns.values]
  novo_df.columns = novo_df.columns.values
  novo_df.columns = pd.MultiIndex.from_tuples(colunas_renomeadas)

  # reformatar valores dos índices
  df_idx_names = novo_df.index.names
  df_idx_values = [(locale_format_int(tamanho), metodo) for tamanho,metodo in novo_df.index.values]
  novo_df.index = pd.MultiIndex.from_tuples(df_idx_values, names=df_idx_names)

  # renomear colunas dos índices
  novo_df.rename_axis(
    index={
      'tamanho_arranjo': 'Tam.',
      'metodo': 'Busca' if cenario is not None else 'Ord.'
    },
    inplace=True
  )

  return novo_df

from pandas.io.formats.style import Styler
def exibir_df(df: pd.DataFrame) -> Styler:
  # associa os formatadores às colunas
  formatters={
    col:(to_ms if 'Tempo' in col[len(col) - 2] else
        locale_format_float if len(col)!=3 or col[0] != 'Pior Caso' else
        locale_format_int)
    for col in df.columns
  }

  # Exibe o df aplicando os formatadores
  return df.style.format(formatters)

# remove colunas não informativas
df_estatisticas_busca = reformatar_df(df_aleatorio, 'Aleatório').join(reformatar_df(df_pior_caso, 'Pior Caso')).drop([
    ('Pior Caso', 'Comp.', 'σ'),  # Será sempre 0
    ('Aleatório', 'x ∈ A', 'σ'),        # Estamos interessados apenas na média, que nos informa o % de chaves pertencente ao arranjo
], axis=1)

exibir_df(df_estatisticas_busca)

# Visualizar resultados - ordenacao
df_estatisticas_ordenacao = reformatar_df(df_timsort)

exibir_df(df_estatisticas_ordenacao)

df_estatisticas_unificado = df_estatisticas_busca.join(reformatar_df(df_timsort.reindex(index=df_aleatorio.index, method='backfill'), 'Ordenação'))

exibir_df(df_estatisticas_unificado)

"""### Salvar resultados"""

import os # Manipulação de FS

def to_latex(df: pd.DataFrame, hide_index: bool = False, **kwargs) -> str:
  if hide_index:
    new_str = exibir_df(df).hide_index().to_latex(hrules=True, **kwargs)
  else:
    new_str = exibir_df(df).to_latex(hrules=True, **kwargs)
  replacements = {
      'x̄': r'$\bar{x}$',
      'σ': r'$\sigma$',
      'x ∈ A': r'$x \in A$',
  }
  for old, new in replacements.items():
    new_str = new_str.replace(old, new)
  return new_str

def save_text(text: str, path: str):
  with open(path, mode='w') as fout:
    fout.write(text)

if not os.path.exists('./resultados'):
  os.mkdir('./resultados')

# Todas as execuções
df.to_csv('./resultados/resultados-todos.csv', sep=';')
df.style.to_excel('./resultados/resultados-todos.xlsx')
# Buscas
df_busca.to_csv('./resultados/resultados-busca.csv', sep=';')
df_busca.style.to_excel('./resultados/resultados-busca.xlsx')
# Ordenação
df_ordenacao.to_csv('./resultados/resultados-ordenacao.csv', sep=';')
df_ordenacao.style.to_excel('./resultados/resultados-ordenacao.xlsx')

# Gerar tabela latex - semi-formatada para inclusão no artigo
save_text(
  to_latex(
    df_estatisticas_unificado,
    clines='skip-last;data',
    caption='Comparação empírica do desempenho dos métodos de busca',
    label='tab:resultados'
  ),
  os.path.join('./resultados', 'tabela-unificada.tex')
)

import shutil
from google.colab import files

shutil.make_archive('resultados', 'zip', 'resultados')

files.download('resultados.zip')

"""## Informações sobre o ambiente"""

import platform

# Plataforma
print(platform.platform())
# Versão Python
print(platform.python_implementation() + ': ' + platform.python_version())
# Pandas
print(pd.show_versions())

!free -m

!cat /proc/meminfo

!cat /proc/cpuinfo

!lscpu